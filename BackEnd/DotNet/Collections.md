Хорошей практикой в **public** методе является:
- входные параметры расширять, обобщать;
- выходные параметры сужать, конкретизировать.

Типичный метод с ошибками:
```csharp
public IEnumerable<T> MyMethod<T>(List<T> list)
{
	var result = ...
	return result;
}
```

Рассмотрим ошибки в приведенном выше методе:
1. Если на вход нужно будет передать [[Array]], то будет ошибка компиляции. Мы хотим добиться чтобы метод был более универсальным, поэтому <u>расширяем входной параметр до [[Collections]]</u>:
```csharp
public IEnumerable<T> MyMethod<T>(Collection<T> collection)
```
   
   2. Если кто-то будет использовать данный метод, то непонятно *"а что же на выходе будет подразумеваться под [[IEnumerable]]?"* Поэтому сужаем до [[IReadOnlyList]]
```csharp
public IReadOnlyList<T> MyMethod<T>(Collection<T> collection)
```
   3. Тогда понятно что это коллекция, которую нельзя изменять, но иногда это вызывает сложности. Тогда делаем ещё более конкретнее и делаем [[List]].

Идеальный метод выглядит так:
```csharp
public List<T> MyMethod<T>(Collection<T> collection)
```
Если хотим чтобы список нельзя было расширить, то возвращаем [[Array]]:

```csharp
public Array<T> MyMethod<T>(Collection<T> collection)
```

Если на вход подаётся [[IEnumerable]], а в методе происходит обращение к коллекции несколько раз, а сам IEnumerable под капотом ещё ходит в базу, то это не хорошо. Поэтому IEnumerable на вход подавать не очень хорошо. 